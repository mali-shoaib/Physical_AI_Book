# Data Model: Embedding Pipeline Setup

**Feature**: 007-embedding-pipeline
**Date**: 2025-12-23
**Purpose**: Define data entities, relationships, and state transitions for the embedding pipeline

---

## Entity: Web Page

**Description**: A published Docusaurus chapter available at a specific URL

**Attributes**:
- `url` (string, unique): Full HTTPS URL of the page
- `html_content` (string): Raw HTML fetched from the URL
- `module_name` (string): Human-readable module identifier (e.g., "Module 1: ROS 2")
- `chapter_id` (string): Path-based identifier (e.g., "module-1-ros2/ch1-basics")
- `fetch_timestamp` (ISO 8601 datetime): When the page was last crawled
- `fetch_status` (enum): `success | failed | skipped`
- `error_message` (string, nullable): Error details if fetch_status = failed

**Validation Rules**:
- URL MUST start with configured DOCUSAURUS_BASE_URL
- URL MUST match pattern `*/docs/*` (no `/blog`, `/api` paths)
- html_content MUST be non-empty if fetch_status = success
- module_name and chapter_id derived from URL path structure

**Relationships**:
- One Web Page produces 1-N Text Chunks

**State Transitions**:
```
[Discovered] → [Fetching] → [Success/Failed]
                    ↓
                [Retry] (max 3 attempts)
```

---

## Entity: Text Chunk

**Description**: A semantically coherent segment of cleaned text from a Web Page, sized for embedding

**Attributes**:
- `chunk_id` (UUID, unique): Globally unique identifier
- `chunk_text` (string): Cleaned text content (512-1024 tokens)
- `token_count` (integer): Exact token count using tiktoken
- `source_url` (string): URL of originating Web Page
- `chapter_id` (string): Inherited from Web Page
- `module_name` (string): Inherited from Web Page
- `heading_hierarchy` (list of strings): Nested headings providing context
  - Example: `["Chapter 1: ROS 2 Basics", "1.2 Installation", "1.2.1 Ubuntu Setup"]`
- `chunk_index` (integer): Position within the chapter (0-based)
- `total_chunks_in_chapter` (integer): Total number of chunks from same chapter
- `overlap_text` (string, nullable): Text overlapping with previous chunk
- `created_timestamp` (ISO 8601 datetime): When chunk was created

**Validation Rules**:
- token_count MUST be between 512 and 1024 (inclusive)
- chunk_text MUST be non-empty
- chunk_index MUST be >= 0
- heading_hierarchy MUST have at least 1 element
- overlap_text length MUST be 10-20% of token_count (if present)

**Relationships**:
- Many Text Chunks belong to one Web Page
- One Text Chunk produces one Embedding Vector

**State Transitions**:
```
[Created] → [Embedding Pending] → [Embedding Success/Failed]
                                        ↓
                                  [Stored in Qdrant]
```

---

## Entity: Embedding Vector

**Description**: A numerical representation of a Text Chunk generated by Cohere

**Attributes**:
- `vector_id` (UUID): Same as chunk_id (one-to-one mapping)
- `vector` (array of float32): 1024-dimensional embedding
- `model_version` (string): Cohere model identifier (e.g., "embed-english-v3.0")
- `embedding_timestamp` (ISO 8601 datetime): When embedding was generated
- `embedding_status` (enum): `success | failed | rate_limited`
- `retry_count` (integer): Number of retry attempts (max 3)

**Validation Rules**:
- vector MUST have exactly 1024 dimensions
- Each dimension MUST be float32 in range [-1.0, 1.0]
- model_version MUST be pinned (no "latest" or variable versions)
- retry_count MUST be <= 3

**Relationships**:
- One Embedding Vector corresponds to one Text Chunk
- One Embedding Vector stored in one Qdrant Point

**State Transitions**:
```
[Pending] → [API Call] → [Success/Rate Limited/Failed]
                ↓ (if rate limited or failed)
            [Retry with backoff]
                ↓ (after 3 failed attempts)
            [Marked Failed]
```

---

## Entity: Qdrant Point

**Description**: A vector with metadata stored in the Qdrant collection

**Attributes** (payload):
- `id` (UUID): Same as chunk_id/vector_id
- `vector` (array of float32): 1024-dimensional embedding
- `metadata` (object):
  - `chunk_id` (string): UUID as string
  - `source_url` (string): Full URL of source Web Page
  - `chapter_id` (string): Path-based chapter identifier
  - `module_name` (string): Human-readable module name
  - `heading_hierarchy` (array of strings): Nested heading path
  - `chunk_index` (integer): Position within chapter
  - `chunk_text` (string): Full text of chunk (for display/debugging)
  - `timestamp` (string): ISO 8601 ingestion time
  - `model_version` (string): Cohere embedding model version

**Validation Rules**:
- id MUST be valid UUIDv4
- vector MUST have 1024 dimensions
- metadata.chunk_text MUST match original Text Chunk content
- metadata.timestamp MUST be valid ISO 8601 format

**Relationships**:
- One Qdrant Point corresponds to one Embedding Vector
- All Qdrant Points belong to one Collection

**Storage Location**: Qdrant collection named `rag_embedding`

---

## Entity: Qdrant Collection

**Description**: A named container holding all embedded chunks for a deployment environment

**Attributes**:
- `name` (string, unique): Collection identifier (fixed: "rag_embedding")
- `vector_size` (integer): Fixed at 1024 (Cohere embed-english-v3.0)
- `distance_metric` (enum): Fixed at "Cosine"
- `total_points` (integer): Number of vectors stored
- `indexing_threshold` (integer): Point count before indexing triggers (default: 10000)
- `created_timestamp` (ISO 8601 datetime): Collection creation time

**Validation Rules**:
- name MUST be "rag_embedding"
- vector_size MUST be 1024
- distance_metric MUST be "Cosine"

**Relationships**:
- One Collection contains 0-N Qdrant Points
- Collection is scoped to one deployment environment (dev/staging/prod)

**State Transitions**:
```
[Not Exists] → [Created] → [Populating] → [Indexed]
                                ↓
                          [Querying Active]
```

---

## Entity: Ingestion Job

**Description**: A single execution of the embedding pipeline from start to finish

**Attributes**:
- `job_id` (UUID, unique): Unique identifier for this run
- `start_timestamp` (ISO 8601 datetime): Job start time
- `end_timestamp` (ISO 8601 datetime, nullable): Job completion time
- `status` (enum): `running | completed | failed | partial_success`
- `base_url` (string): Docusaurus base URL crawled
- `stats` (object):
  - `pages_discovered` (integer): Total URLs found
  - `pages_fetched_success` (integer): Successfully downloaded
  - `pages_fetched_failed` (integer): Failed downloads
  - `chunks_created` (integer): Total chunks generated
  - `embeddings_generated` (integer): Successful embeddings
  - `embeddings_failed` (integer): Failed embeddings
  - `qdrant_upserts_success` (integer): Successful stores
  - `qdrant_upserts_failed` (integer): Failed stores
- `errors` (array of objects): List of errors encountered
  - `error_type` (string): Category (fetch_error, embed_error, store_error)
  - `url_or_chunk_id` (string): Identifier of failed item
  - `message` (string): Error description
  - `timestamp` (ISO 8601 datetime): When error occurred
- `duration_seconds` (integer): Total job runtime

**Validation Rules**:
- start_timestamp MUST be set when job begins
- status MUST be `running` until completion
- stats counters MUST be non-negative
- pages_fetched_success + pages_fetched_failed MUST equal pages_discovered
- duration_seconds = end_timestamp - start_timestamp

**Relationships**:
- One Ingestion Job processes N Web Pages
- One Ingestion Job generates N Text Chunks
- One Ingestion Job creates N Embedding Vectors
- One Ingestion Job stores N Qdrant Points

**State Transitions**:
```
[Initialized] → [Crawling URLs] → [Fetching Pages] → [Chunking Text] →
  [Generating Embeddings] → [Storing in Qdrant] → [Completed/Failed]
                                ↓ (any stage)
                           [Error Logged]
```

**Summary Report Format** (at completion):
```json
{
  "job_id": "uuid",
  "status": "completed",
  "duration_seconds": 900,
  "stats": {
    "pages_discovered": 120,
    "pages_fetched_success": 118,
    "pages_fetched_failed": 2,
    "chunks_created": 850,
    "embeddings_generated": 845,
    "embeddings_failed": 5,
    "qdrant_upserts_success": 845,
    "qdrant_upserts_failed": 0
  },
  "success_rate": 99.4,
  "errors": [
    {"error_type": "fetch_error", "url": "...", "message": "404 Not Found"},
    ...
  ]
}
```

---

## Entity Relationships Diagram

```
Web Page (1) ──produces──> (N) Text Chunk
                               │
                               │ creates
                               ↓
                          Embedding Vector (1:1)
                               │
                               │ stored as
                               ↓
                          Qdrant Point
                               │
                               │ belongs to
                               ↓
                          Qdrant Collection

Ingestion Job ──processes──> Web Pages
              ──generates──> Text Chunks
              ──creates──> Embedding Vectors
              ──stores──> Qdrant Points
```

---

## Data Flow

1. **Crawl Phase**:
   - Fetch sitemap.xml → extract URLs → create Web Page entities
   - Filter URLs (only `/docs/*` paths)

2. **Extract Phase**:
   - For each Web Page: fetch HTML → clean → extract text
   - Derive metadata (module_name, chapter_id, heading_hierarchy)

3. **Chunk Phase**:
   - Split text using recursive algorithm (headers → paragraphs → sentences)
   - Create Text Chunk entities with 10-20% overlap
   - Validate token counts (512-1024)

4. **Embed Phase**:
   - Batch Text Chunks (up to 96 per API call)
   - Call Cohere API → create Embedding Vector entities
   - Handle rate limits with exponential backoff

5. **Store Phase**:
   - Upsert Qdrant Points (vector + metadata)
   - Update Ingestion Job stats
   - Log errors for failed operations

6. **Validate Phase**:
   - Run test queries against Qdrant
   - Check similarity scores > 0.70
   - Generate summary report

---

## Indexing & Query Optimization

**Qdrant Indexing**:
- Auto-indexes when collection reaches 10,000 points
- HNSW index parameters:
  - `m`: 16 (default, balance accuracy/speed)
  - `ef_construct`: 100 (build-time accuracy)
  - `ef`: 128 (query-time accuracy)

**Query Filtering**:
- Filter by `metadata.module_name` for module-specific queries
- Filter by `metadata.chapter_id` for chapter-specific context

**Example Query**:
```python
client.search(
    collection_name="rag_embedding",
    query_vector=query_embedding,
    limit=5,
    query_filter={
        "must": [
            {"key": "metadata.module_name", "match": {"value": "Module 1: ROS 2"}}
        ]
    }
)
```

---

## Incremental Update Strategy

**Change Detection**:
- Store `fetch_timestamp` for each Web Page in separate tracking DB (or JSON file)
- On incremental run: fetch current timestamp of URL (HTTP HEAD request with `Last-Modified` header)
- If `Last-Modified` > stored `fetch_timestamp` → re-process page

**Update Process**:
1. Identify changed URLs
2. Delete old Qdrant Points with matching `source_url`
3. Re-extract, re-chunk, re-embed, re-store
4. Update tracking DB with new timestamp

**Deletion Handling**:
- If URL returns 404: delete associated Qdrant Points
- If URL removed from sitemap: mark for deletion

---

## Validation & Quality Assurance

**Test Query Schema**:
```python
{
    "query_id": str,
    "query_text": str,
    "expected_module": str,  # e.g., "module-1-ros2"
    "expected_chapter_id": str,  # e.g., "module-1-ros2/ch1-basics"
    "min_similarity": float  # e.g., 0.70
}
```

**Validation Pass Criteria**:
- At least one retrieved chunk has similarity > `min_similarity`
- Retrieved chunk's `metadata.module_name` matches `expected_module`
- 95% of test queries pass validation

---

## Error Handling Schema

**Error Types**:
- `fetch_error`: HTTP errors, timeouts during page fetch
- `extraction_error`: HTML parsing failures, malformed content
- `chunking_error`: Text too short/long, invalid token counts
- `embed_error`: Cohere API failures, rate limits
- `store_error`: Qdrant connection failures, upsert errors

**Error Logging Format**:
```python
{
    "error_id": UUID,
    "error_type": str,
    "stage": str,  # "crawl" | "extract" | "chunk" | "embed" | "store"
    "resource_id": str,  # URL or chunk_id
    "message": str,
    "traceback": str,
    "timestamp": ISO 8601,
    "retry_count": int
}
```

---

## Summary

This data model defines 6 core entities with clear relationships, validation rules, and state transitions. All entities support the functional requirements from the spec and align with constitution principles (Cohere embeddings, Qdrant storage, metadata preservation).
